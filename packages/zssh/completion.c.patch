--- a/completion.c
+++ b/completion.c
@@ -41,8 +41,14 @@
 /* Tell the GNU Readline library how to complete.  We want to try to complete
  on command names if this is the first word in the line, or on filenames
  if not. */
-void	initialize_readline()
+
+/* Prototypes for readline callbacks */
+static char **zssh_completion(const char *text, int start, int end);
+static char *command_generator(const char *text, int state);
+static char *fake_generator(const char *text, int state);
+
+void	initialize_readline(void)
 {
 #ifdef DEBUG
    printf("Using readline library version: %s\n", rl_library_version);
 #endif
@@ -53,7 +59,7 @@
 	   /* inhibit default filename completion
 	    so that if zssh_completion() fails nothing is completed */
 	   rl_completion_entry_function = fake_generator;
 	   /* Tell the completer that we want a crack first. */
-	   rl_attempted_completion_function = (CPPFunction *) zssh_completion;
+	   rl_attempted_completion_function = zssh_completion;
 	   
 }
@@ -62,11 +68,7 @@
  the word to complete.  We can use the entire contents of rl_line_buffer
  in case we want to do some simple parsing.  Return the array of matches,
  or NULL if there aren't any. */
-char		**zssh_completion(text, start, end)
-char		*text;
-int		start;
-int		end;
+static char **zssh_completion(const char *text, int start, int end)
 {
    char		**matches;
@@ -89,9 +91,7 @@
 /* Generator function for command completion.  STATE lets us know whether
  to start from scratch; without any state (i.e. STATE == 0), then we
  start at the top of the list. */
-char		*command_generator(text, state)
-const char	*text;
-int		state;
+static char *command_generator(const char *text, int state)
 {
    static int	list_index, len;
    char		*name;
@@ -125,9 +125,7 @@
 
 	/* If no names matched, then return NULL. */
 	return ((char *)NULL);
 }
@@ -153,10 +151,7 @@
 	}
 	#endif /* 0 */
 
-char			*fake_generator(text, state)
-const char		*text;
-int			state;
+static char *fake_generator(const char *text, int state)
 {
 	return (0);
 }
